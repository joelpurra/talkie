/*
This file is part of Talkie -- text-to-speech browser extension button.
<https://joelpurra.com/projects/talkie/>

Copyright (c) 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024 Joel Purra <https://joelpurra.com/>

Talkie is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Talkie is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Talkie.  If not, see <https://www.gnu.org/licenses/>.
*/

import type {
	MessageBusAction,
	MessageBusActionHandler,
} from "@talkie/split-environment-interfaces/imessage-bus.mjs";
import type {
	IStartStop,
} from "@talkie/split-environment-interfaces/istart-stop.mjs";
import type {
	JsonValue,
} from "type-fest";

import {
	logError,
} from "@talkie/shared-application-helpers/log.mjs";
import {
	type IMessageBusProviderGetter,
	type MessageBusCallbackResponse,
	TALKIE_MESSAGE_BUS_HANDLER_DONE_RESPONSE,
} from "@talkie/split-environment-interfaces/imessage-bus-provider.mjs";

import MessageBusBase from "./message-bus-base.mjs";
import {
	isValidMessageBusMessage,
} from "./message-bus-helper.mjs";

export default abstract class MessageBusListener extends MessageBusBase implements IStartStop {
	// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
	constructor(action: MessageBusAction, messageBusProviderGetter: IMessageBusProviderGetter, private readonly messageBusHandler: MessageBusActionHandler) {
		super(action, messageBusProviderGetter);
	}

	public async start(): Promise<void> {
		if (typeof this._onMessageFilterBound !== "function") {
			throw new TypeError("this._onMessageFilterBound");
		}

		const messageBusProvider = await this.messageBusProviderGetter.messageBusProvider;

		if (messageBusProvider.onMessage.hasListener(this._onMessageFilterBound)) {
			throw new Error("MessageBusHandlerManager: onMessage listener was already registered");
		}

		messageBusProvider.onMessage.addListener(this._onMessageFilterBound);
	}

	public async stop(): Promise<void> {
		// NOTE: this asynchronous cleanup method may not be allowed execute to completion.
		if (typeof this._onMessageFilterBound !== "function") {
			throw new TypeError("MessageBusHandlerManager: Not initialized.");
		}

		const messageBusProvider = await this.messageBusProviderGetter.messageBusProvider;

		if (!messageBusProvider.onMessage.hasListener(this._onMessageFilterBound)) {
			throw new Error("MessageBusHandlerManager: onMessage listener was not registered.");
		}

		messageBusProvider.onMessage.removeListener(this._onMessageFilterBound);

		// NOTE: the handler deliberately cannot be restarted.
		this._onMessageFilterBound = null;
	}

	// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
	private async _onMessageFilter(message: JsonValue): Promise<MessageBusCallbackResponse> {
		// NOTE: will receive messages intended for other events; need to filter/match.
		const isValid = isValidMessageBusMessage(message, this.inboundDirection);

		if (!isValid) {
			// NOTE: message was not generated by, and thus not intended for, Talkie?
			return;
		}

		if (message.action !== this.action) {
			// NOTE: ignore non-matching messages; no response.
			return;
		}

		return this._onMessageHandler(message.action, message.datum);
	}

	// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
	private async _onMessageHandler(action: MessageBusAction, data: JsonValue): Promise<MessageBusCallbackResponse> {
		let rawResponseDatum;

		try {
			// NOTE: awaiting handling also for the case when there will be no response, because it can easily be avoided by the caller.
			rawResponseDatum = await this.messageBusHandler(action, data);
		} catch (error: unknown) {
			// TODO: propagate failure as part of the message response?
			void logError(`_onMessageHandler(...) for ${this.action}; will return undefined.`, "swallowing error", error);
		}

		// NOTE: reassigning to a const since the value won't be changed below.
		const responseDatum = rawResponseDatum;

		switch (this.responseMode) {
			case "response:required": {
				if (responseDatum === undefined) {
					throw new TypeError(`Expected a response, but got undefined for ${this.action}.`);
				}

				// NOTE: defined response; assemble a message.
				return this._assembleMessage(responseDatum);
			}

			case "response:acknowledgment": {
				if (responseDatum !== undefined && responseDatum !== TALKIE_MESSAGE_BUS_HANDLER_DONE_RESPONSE) {
					throw new TypeError(`Expected undefined or TALKIE_MESSAGE_BUS_HANDLER_DONE_RESPONSE response, but got ${JSON.stringify(responseDatum, null, 0)} for ${this.action}.`);
				}

				// NOTE: respond "undefined" to "non-acks" as they are expected to not interfere with the "real" processing.
				if (responseDatum === undefined) {
					return undefined;
				}

				// NOTE: indicator for "no response" from the (presumed singular) "responsible" message handler; assemble a "processing done" message.
				return this._assembleMessage(TALKIE_MESSAGE_BUS_HANDLER_DONE_RESPONSE);
			}

			case "response:disallowed": {
				if (responseDatum !== undefined) {
					throw new TypeError(`Expected no response, but got ${JSON.stringify(responseDatum, null, 0)} for ${this.action}.`);
				}

				// NOTE: no response; none expected.
				return undefined;
			}
		}
	}

	// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
	private _onMessageFilterBound: (typeof this._onMessageFilter) | null = async (message) => this._onMessageFilter(message);
}
